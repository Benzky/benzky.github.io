<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>kdtree API documentation</title>
<meta name="description" content="This module is a library containing the k-d tree class …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kdtree</code></h1>
</header>
<section id="section-intro">
<p>This module is a library containing the k-d tree class.</p>
<p>A k-d tree, or k-dimensional tree, is a data structure
used for organizing points in a k-dimensional space. </p>
<p>The k-d tree in this module is an unblanaced k-d tree. This means
that adding elements frequently will make the tree unbalanced and
risk losing the advantages of the data structure. One of the
advantages of the k-d tree is it's range and nearest neighbor search.
Because of the tree structure nearest neighbor searches only take O(log n) time.</p>
<h2 id="example">Example</h2>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; from kdtree import kdtree
&gt;&gt;&gt; tree = kdtree([(1,1),(-3,0.6),(100,32),(32,0x42)])
&gt;&gt;&gt; tree
((32, 66), ((1, 1), ((-3, 0.6), None, None), None), ((100, 32), None, None))

&gt;&gt;&gt; tree.nearest((-2,1))
(-3, 0.6)
&gt;&gt;&gt; tree.nearest((50,0))
(1, 1)

&gt;&gt;&gt; tree.list()
[(32, 66), (1, 1), (-3, 0.6), (100, 32)]

&gt;&gt;&gt; tree.add((9,3))
&gt;&gt;&gt; tree.list()
[(32, 66), (1, 1), (-3, 0.6), (9, 3), (100, 32)]
</code></pre>
<h2 id="todo">Todo</h2>
<ul>
<li>Make it a balanced tree.</li>
<li>Improve documentation.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module is a library containing the k-d tree class.

A k-d tree, or k-dimensional tree, is a data structure
used for organizing points in a k-dimensional space. 

The k-d tree in this module is an unblanaced k-d tree. This means
that adding elements frequently will make the tree unbalanced and
risk losing the advantages of the data structure. One of the 
advantages of the k-d tree is it&#39;s range and nearest neighbor search. 
Because of the tree structure nearest neighbor searches only take O(log n) time.

Example:
    Example usage:
        
        &gt;&gt;&gt; from kdtree import kdtree
        &gt;&gt;&gt; tree = kdtree([(1,1),(-3,0.6),(100,32),(32,0x42)])
        &gt;&gt;&gt; tree
        ((32, 66), ((1, 1), ((-3, 0.6), None, None), None), ((100, 32), None, None))
        
        &gt;&gt;&gt; tree.nearest((-2,1))
        (-3, 0.6)
        &gt;&gt;&gt; tree.nearest((50,0))
        (1, 1)
        
        &gt;&gt;&gt; tree.list()
        [(32, 66), (1, 1), (-3, 0.6), (100, 32)]
        
        &gt;&gt;&gt; tree.add((9,3))
        &gt;&gt;&gt; tree.list()
        [(32, 66), (1, 1), (-3, 0.6), (9, 3), (100, 32)]

Todo:
    * Make it a balanced tree.
    * Improve documentation.
&#34;&#34;&#34;

class kdtree:
    &#34;&#34;&#34;A class for storing and searching for points in k-dimensional space.
    &#34;&#34;&#34;
    
    def __init__(self, points, depth = 0):
        &#34;&#34;&#34;
        Args:
            points (List[tuple]): List of k-tuples to add to the k-d tree.
            depth (int): Depth of the k-d tree.
        &#34;&#34;&#34;
        if points:
            n = len(points[0])
            
            self._axis = depth % n
            
            points.sort(key = lambda x: x[self._axis])
            mid = len(points)//2
            
            self._point = points[mid]
            self._left = kdtree(points[:mid], depth + 1) if points[:mid] else None
            self._right = kdtree(points[mid + 1:], depth + 1) if points[mid + 1:] else None
        else:
            self._point = None
            self._right = None
            self._left = None
            if self._right:
                del self._right
            if self._left:
                del self._left
    
    def nearest(self, point, best = None):
        &#34;&#34;&#34;Returns the point in the tree closest to the search target
        using nearest neighbor search.
        
        If there are more than one the same distance away from the point
        it returns one of them.
        
        Args:
            point (tuple): The search target. 
            best (tuple): The point in the tree currently closest to the search target.
        
        Returns:
            tuple: The point in the tree closest to the search target.
        &#34;&#34;&#34;
        # Smärtsamt
        if self is None:
            return best
        
        if best is None:
            best = self._point
        elif self._distsquared(self._point, point) &lt; self._distsquared(best, point):
            best = self._point
            
        if self._besttree(point):
            best = self._besttree(point).nearest(point, best)
        
        if self._axisdist(point) &lt; self._distsquared(best, point) and self._notbesttree(point):
            best = self._notbesttree(point).nearest(point,best)
        
        return best
    
    def add(self, point):
        &#34;&#34;&#34;Adds a point as a leaf to the correct branch of the tree.
        
        Args:
            point (tuple): The point to add.
        &#34;&#34;&#34;
        if self._point:
            if point[self._axis] &lt; self._point[self._axis]:
                if self._left:
                    self._left.add(point)
                else:
                    self._left = kdtree([point])
            else:
                if self._right:
                    self._right.add(point)
                else:
                    self._right = kdtree([point])
        else:
            self.__init__([point])
    
    def recreate(self):
        &#34;&#34;&#34;Rebalances the tree by recreating it from scratch.
        &#34;&#34;&#34;
        if self._point:
            self.__init__(self.list(), 0 if self._axis == 0 else 1)

    def list(self):
        &#34;&#34;&#34;Returns an unsorted list of all the points in the tree.
        
        Returns:
            List[tuple]: An unsorted list of points in the tree.            
        &#34;&#34;&#34;
        if self._point:
            return self._listhelp([])
        return []
    
    def remove(self, point):
        &#34;&#34;&#34;Removes a point from the tree.
        
        Does nothing if the point isn&#39;t in the tree.
        
        Args:
            point (tuple): Point to remove.
        &#34;&#34;&#34;
        if self._point is None:
            return None
        
        if self._point == point:
            l = self.list()
            l.remove(point)
            self.__init__(l, 0 if self._axis == 0 else 1)
            return None
            
        b = self._besttree(point)
        
        if b:
            if b._point == point and b._left is None and b._right is None:
                if b == self._left:
                    self._left = None
                else:
                    self._right = None
            else:
                b.remove(point)
    
    def rangesearch(self, range_, inside=None):
        &#34;&#34;&#34;Returns a list with all points inside the 
        range including end points.
        
        Ranges for all dimensions must be specified.
        
        Args:
            range_ (List[tuple]): A list with the range.
        
        Returns:
            List[tuple]: A list with all the points within the range.
            
        Example:
            Example usage:
            
                &gt;&gt;&gt; tree = kdtree([(7,2), (5,4), (9,6), (4,7), (8,1), (2,3)])
                &gt;&gt;&gt; range_ = [(6,9),(0,10)]
                &gt;&gt;&gt; tree.rangesearch(range_)
                [(7, 2), (9, 6), (8, 1)]
        &#34;&#34;&#34;
        if inside is None:
            inside = []
        if self._inrange(range_, self._point):
            inside.append(self._point)
        if self._point[self._axis] &lt;= range_[self._axis][1]:
            self._right.rangesearch(range_, inside) if self._right else None
        if self._point[self._axis] &gt;= range_[self._axis][0]:
            self._left.rangesearch(range_, inside) if self._left else None
        return inside
    
    def _inrange(self, range_, point):
        for i in range(len(point)):
            if point[i] &lt; range_[i][0] or point[i] &gt; range_[i][1]:
                return False
        return True
    
    def _listhelp(self, list):
        list.append(self._point)
        if self._left:
            self._left._listhelp(list)
        if self._right:
            self._right._listhelp(list)
        return list
    
    def _besttree(self, point):
        # Nya rön tyder på att det är effektivt att utnyttja
        # alla fördelar med den data struktur du valt
        if point[self._axis] &lt; self._point[self._axis]:
            return self._left if self._left else None
        return self._right if self._right else None
    
    def _axisdist(self, point):
        # Stor applåd till tuple för att inte kunna ändra innehåll
        axpoint = list(point)
        axpoint[self._axis] = self._point[self._axis]
        return self._distsquared(tuple(axpoint), point)
    
    def _notbesttree(self, point):
        if self._besttree(point) is self._left:
            return self._right
        return self._left
    
    def _distsquared(self, a, b):
        if len(a) != len(b):
            raise IndexError(&#34;Two points within the tree are of different length&#34;)
        return sum((a[i]-b[i])**2 for i in range(len(a)))
    
    def __repr__(self):
        &#34;&#34;&#34;Returns a string representation of the k-d tree.
        
        Returns:
            string: A representation of the tree.
        &#34;&#34;&#34;
        return &#34;, &#34;.join([str(self._point),self._left.__repr__(),self._right.__repr__()]).join([&#34;(&#34;,&#34;)&#34;])


def distsquared(a, b):
    &#34;&#34;&#34;Returns the squared distance between two points a and b.
    
    Args:
        a (tuple): The first point.
        b (tuple): The second point.
        
    Returns:
        float: The squared distance between a and b.
    &#34;&#34;&#34;
    # Ifall man vill använda den här funktionen till något annat.
    # Måste ha en separat om man bara vill importera trädet och
    # inte den här funktionen för att trädet ska fungera.
    if len(a) != len(b):
        raise IndexError(&#34;The two points are of different length&#34;)
    return sum((a[i]-b[i])**2 for i in range(len(a)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kdtree.distsquared"><code class="name flex">
<span>def <span class="ident">distsquared</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the squared distance between two points a and b.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The first point.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The second point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The squared distance between a and b.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distsquared(a, b):
    &#34;&#34;&#34;Returns the squared distance between two points a and b.
    
    Args:
        a (tuple): The first point.
        b (tuple): The second point.
        
    Returns:
        float: The squared distance between a and b.
    &#34;&#34;&#34;
    # Ifall man vill använda den här funktionen till något annat.
    # Måste ha en separat om man bara vill importera trädet och
    # inte den här funktionen för att trädet ska fungera.
    if len(a) != len(b):
        raise IndexError(&#34;The two points are of different length&#34;)
    return sum((a[i]-b[i])**2 for i in range(len(a)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kdtree.kdtree"><code class="flex name class">
<span>class <span class="ident">kdtree</span></span>
<span>(</span><span>points, depth=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for storing and searching for points in k-dimensional space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>List[tuple]</code></dt>
<dd>List of k-tuples to add to the k-d tree.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code></dt>
<dd>Depth of the k-d tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class kdtree:
    &#34;&#34;&#34;A class for storing and searching for points in k-dimensional space.
    &#34;&#34;&#34;
    
    def __init__(self, points, depth = 0):
        &#34;&#34;&#34;
        Args:
            points (List[tuple]): List of k-tuples to add to the k-d tree.
            depth (int): Depth of the k-d tree.
        &#34;&#34;&#34;
        if points:
            n = len(points[0])
            
            self._axis = depth % n
            
            points.sort(key = lambda x: x[self._axis])
            mid = len(points)//2
            
            self._point = points[mid]
            self._left = kdtree(points[:mid], depth + 1) if points[:mid] else None
            self._right = kdtree(points[mid + 1:], depth + 1) if points[mid + 1:] else None
        else:
            self._point = None
            self._right = None
            self._left = None
            if self._right:
                del self._right
            if self._left:
                del self._left
    
    def nearest(self, point, best = None):
        &#34;&#34;&#34;Returns the point in the tree closest to the search target
        using nearest neighbor search.
        
        If there are more than one the same distance away from the point
        it returns one of them.
        
        Args:
            point (tuple): The search target. 
            best (tuple): The point in the tree currently closest to the search target.
        
        Returns:
            tuple: The point in the tree closest to the search target.
        &#34;&#34;&#34;
        # Smärtsamt
        if self is None:
            return best
        
        if best is None:
            best = self._point
        elif self._distsquared(self._point, point) &lt; self._distsquared(best, point):
            best = self._point
            
        if self._besttree(point):
            best = self._besttree(point).nearest(point, best)
        
        if self._axisdist(point) &lt; self._distsquared(best, point) and self._notbesttree(point):
            best = self._notbesttree(point).nearest(point,best)
        
        return best
    
    def add(self, point):
        &#34;&#34;&#34;Adds a point as a leaf to the correct branch of the tree.
        
        Args:
            point (tuple): The point to add.
        &#34;&#34;&#34;
        if self._point:
            if point[self._axis] &lt; self._point[self._axis]:
                if self._left:
                    self._left.add(point)
                else:
                    self._left = kdtree([point])
            else:
                if self._right:
                    self._right.add(point)
                else:
                    self._right = kdtree([point])
        else:
            self.__init__([point])
    
    def recreate(self):
        &#34;&#34;&#34;Rebalances the tree by recreating it from scratch.
        &#34;&#34;&#34;
        if self._point:
            self.__init__(self.list(), 0 if self._axis == 0 else 1)

    def list(self):
        &#34;&#34;&#34;Returns an unsorted list of all the points in the tree.
        
        Returns:
            List[tuple]: An unsorted list of points in the tree.            
        &#34;&#34;&#34;
        if self._point:
            return self._listhelp([])
        return []
    
    def remove(self, point):
        &#34;&#34;&#34;Removes a point from the tree.
        
        Does nothing if the point isn&#39;t in the tree.
        
        Args:
            point (tuple): Point to remove.
        &#34;&#34;&#34;
        if self._point is None:
            return None
        
        if self._point == point:
            l = self.list()
            l.remove(point)
            self.__init__(l, 0 if self._axis == 0 else 1)
            return None
            
        b = self._besttree(point)
        
        if b:
            if b._point == point and b._left is None and b._right is None:
                if b == self._left:
                    self._left = None
                else:
                    self._right = None
            else:
                b.remove(point)
    
    def rangesearch(self, range_, inside=None):
        &#34;&#34;&#34;Returns a list with all points inside the 
        range including end points.
        
        Ranges for all dimensions must be specified.
        
        Args:
            range_ (List[tuple]): A list with the range.
        
        Returns:
            List[tuple]: A list with all the points within the range.
            
        Example:
            Example usage:
            
                &gt;&gt;&gt; tree = kdtree([(7,2), (5,4), (9,6), (4,7), (8,1), (2,3)])
                &gt;&gt;&gt; range_ = [(6,9),(0,10)]
                &gt;&gt;&gt; tree.rangesearch(range_)
                [(7, 2), (9, 6), (8, 1)]
        &#34;&#34;&#34;
        if inside is None:
            inside = []
        if self._inrange(range_, self._point):
            inside.append(self._point)
        if self._point[self._axis] &lt;= range_[self._axis][1]:
            self._right.rangesearch(range_, inside) if self._right else None
        if self._point[self._axis] &gt;= range_[self._axis][0]:
            self._left.rangesearch(range_, inside) if self._left else None
        return inside
    
    def _inrange(self, range_, point):
        for i in range(len(point)):
            if point[i] &lt; range_[i][0] or point[i] &gt; range_[i][1]:
                return False
        return True
    
    def _listhelp(self, list):
        list.append(self._point)
        if self._left:
            self._left._listhelp(list)
        if self._right:
            self._right._listhelp(list)
        return list
    
    def _besttree(self, point):
        # Nya rön tyder på att det är effektivt att utnyttja
        # alla fördelar med den data struktur du valt
        if point[self._axis] &lt; self._point[self._axis]:
            return self._left if self._left else None
        return self._right if self._right else None
    
    def _axisdist(self, point):
        # Stor applåd till tuple för att inte kunna ändra innehåll
        axpoint = list(point)
        axpoint[self._axis] = self._point[self._axis]
        return self._distsquared(tuple(axpoint), point)
    
    def _notbesttree(self, point):
        if self._besttree(point) is self._left:
            return self._right
        return self._left
    
    def _distsquared(self, a, b):
        if len(a) != len(b):
            raise IndexError(&#34;Two points within the tree are of different length&#34;)
        return sum((a[i]-b[i])**2 for i in range(len(a)))
    
    def __repr__(self):
        &#34;&#34;&#34;Returns a string representation of the k-d tree.
        
        Returns:
            string: A representation of the tree.
        &#34;&#34;&#34;
        return &#34;, &#34;.join([str(self._point),self._left.__repr__(),self._right.__repr__()]).join([&#34;(&#34;,&#34;)&#34;])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="kdtree.kdtree.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a point as a leaf to the correct branch of the tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The point to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, point):
    &#34;&#34;&#34;Adds a point as a leaf to the correct branch of the tree.
    
    Args:
        point (tuple): The point to add.
    &#34;&#34;&#34;
    if self._point:
        if point[self._axis] &lt; self._point[self._axis]:
            if self._left:
                self._left.add(point)
            else:
                self._left = kdtree([point])
        else:
            if self._right:
                self._right.add(point)
            else:
                self._right = kdtree([point])
    else:
        self.__init__([point])</code></pre>
</details>
</dd>
<dt id="kdtree.kdtree.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an unsorted list of all the points in the tree.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[tuple]</code></dt>
<dd>An unsorted list of points in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    &#34;&#34;&#34;Returns an unsorted list of all the points in the tree.
    
    Returns:
        List[tuple]: An unsorted list of points in the tree.            
    &#34;&#34;&#34;
    if self._point:
        return self._listhelp([])
    return []</code></pre>
</details>
</dd>
<dt id="kdtree.kdtree.nearest"><code class="name flex">
<span>def <span class="ident">nearest</span></span>(<span>self, point, best=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the point in the tree closest to the search target
using nearest neighbor search.</p>
<p>If there are more than one the same distance away from the point
it returns one of them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The search target. </dd>
<dt><strong><code>best</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The point in the tree currently closest to the search target.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The point in the tree closest to the search target.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest(self, point, best = None):
    &#34;&#34;&#34;Returns the point in the tree closest to the search target
    using nearest neighbor search.
    
    If there are more than one the same distance away from the point
    it returns one of them.
    
    Args:
        point (tuple): The search target. 
        best (tuple): The point in the tree currently closest to the search target.
    
    Returns:
        tuple: The point in the tree closest to the search target.
    &#34;&#34;&#34;
    # Smärtsamt
    if self is None:
        return best
    
    if best is None:
        best = self._point
    elif self._distsquared(self._point, point) &lt; self._distsquared(best, point):
        best = self._point
        
    if self._besttree(point):
        best = self._besttree(point).nearest(point, best)
    
    if self._axisdist(point) &lt; self._distsquared(best, point) and self._notbesttree(point):
        best = self._notbesttree(point).nearest(point,best)
    
    return best</code></pre>
</details>
</dd>
<dt id="kdtree.kdtree.rangesearch"><code class="name flex">
<span>def <span class="ident">rangesearch</span></span>(<span>self, range_, inside=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list with all points inside the
range including end points.</p>
<p>Ranges for all dimensions must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>range_</code></strong> :&ensp;<code>List[tuple]</code></dt>
<dd>A list with the range.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[tuple]</code></dt>
<dd>A list with all the points within the range.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Example usage:</p>
<pre><code>&gt;&gt;&gt; tree = kdtree([(7,2), (5,4), (9,6), (4,7), (8,1), (2,3)])
&gt;&gt;&gt; range_ = [(6,9),(0,10)]
&gt;&gt;&gt; tree.rangesearch(range_)
[(7, 2), (9, 6), (8, 1)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rangesearch(self, range_, inside=None):
    &#34;&#34;&#34;Returns a list with all points inside the 
    range including end points.
    
    Ranges for all dimensions must be specified.
    
    Args:
        range_ (List[tuple]): A list with the range.
    
    Returns:
        List[tuple]: A list with all the points within the range.
        
    Example:
        Example usage:
        
            &gt;&gt;&gt; tree = kdtree([(7,2), (5,4), (9,6), (4,7), (8,1), (2,3)])
            &gt;&gt;&gt; range_ = [(6,9),(0,10)]
            &gt;&gt;&gt; tree.rangesearch(range_)
            [(7, 2), (9, 6), (8, 1)]
    &#34;&#34;&#34;
    if inside is None:
        inside = []
    if self._inrange(range_, self._point):
        inside.append(self._point)
    if self._point[self._axis] &lt;= range_[self._axis][1]:
        self._right.rangesearch(range_, inside) if self._right else None
    if self._point[self._axis] &gt;= range_[self._axis][0]:
        self._left.rangesearch(range_, inside) if self._left else None
    return inside</code></pre>
</details>
</dd>
<dt id="kdtree.kdtree.recreate"><code class="name flex">
<span>def <span class="ident">recreate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rebalances the tree by recreating it from scratch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recreate(self):
    &#34;&#34;&#34;Rebalances the tree by recreating it from scratch.
    &#34;&#34;&#34;
    if self._point:
        self.__init__(self.list(), 0 if self._axis == 0 else 1)</code></pre>
</details>
</dd>
<dt id="kdtree.kdtree.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a point from the tree.</p>
<p>Does nothing if the point isn't in the tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Point to remove.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, point):
    &#34;&#34;&#34;Removes a point from the tree.
    
    Does nothing if the point isn&#39;t in the tree.
    
    Args:
        point (tuple): Point to remove.
    &#34;&#34;&#34;
    if self._point is None:
        return None
    
    if self._point == point:
        l = self.list()
        l.remove(point)
        self.__init__(l, 0 if self._axis == 0 else 1)
        return None
        
    b = self._besttree(point)
    
    if b:
        if b._point == point and b._left is None and b._right is None:
            if b == self._left:
                self._left = None
            else:
                self._right = None
        else:
            b.remove(point)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kdtree.distsquared" href="#kdtree.distsquared">distsquared</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kdtree.kdtree" href="#kdtree.kdtree">kdtree</a></code></h4>
<ul class="two-column">
<li><code><a title="kdtree.kdtree.add" href="#kdtree.kdtree.add">add</a></code></li>
<li><code><a title="kdtree.kdtree.list" href="#kdtree.kdtree.list">list</a></code></li>
<li><code><a title="kdtree.kdtree.nearest" href="#kdtree.kdtree.nearest">nearest</a></code></li>
<li><code><a title="kdtree.kdtree.rangesearch" href="#kdtree.kdtree.rangesearch">rangesearch</a></code></li>
<li><code><a title="kdtree.kdtree.recreate" href="#kdtree.kdtree.recreate">recreate</a></code></li>
<li><code><a title="kdtree.kdtree.remove" href="#kdtree.kdtree.remove">remove</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>